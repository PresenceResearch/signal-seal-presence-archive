import os
import json
from datetime import datetime, date
from typing import List

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import streamlit as st

# ------------------------------------
# Paths
# ------------------------------------
RAW_DIR = os.path.abspath("data/raw")
PROC_DIR = os.path.abspath("data/processed")
FIG_DIR = os.path.join(PROC_DIR, "figures")
CSV_PATH = os.path.join(PROC_DIR, "scoring_log.csv")

os.makedirs(RAW_DIR, exist_ok=True)
os.makedirs(PROC_DIR, exist_ok=True)
os.makedirs(FIG_DIR, exist_ok=True)

st.set_page_config(page_title="Presence Dashboard", page_icon="✨", layout="wide")
st.title("Presence Dashboard ✨")
st.caption("Scores + timelines from /data/processed/scoring_log.csv — generated by the Jupyter scorer.")

# ------------------------------------
# Load Data
# ------------------------------------
@st.cache_data(show_spinner=False)
def load_scores(csv_path: str) -> pd.DataFrame:
    if not os.path.exists(csv_path) or os.path.getsize(csv_path) == 0:
        return pd.DataFrame(columns=["date","file_name","E","C","R","P","tags","notes","id"])
    df = pd.read_csv(csv_path)
    # Coerce types
    for col in ["E","C","R","P"]:
        df[col] = pd.to_numeric(df[col], errors="coerce")
    df["date"] = pd.to_datetime(df["date"], errors="coerce")
    # Normalize tags into list form
    df["_tags_list"] = (df["tags"].fillna("")
                         .apply(lambda s: [t.strip() for t in s.split(",") if t.strip()]))
    return df

scores = load_scores(CSV_PATH)

if scores.empty:
    st.info("No scores yet. Open the Jupyter notebook, save a few ratings, then refresh this page.")
    st.stop()

# ------------------------------------
# Sidebar Filters
# ------------------------------------
with st.sidebar:
    st.header("Filters")
    min_date = pd.to_datetime(scores["date"].min()).date() if scores["date"].notna().any() else date.today()
    max_date = pd.to_datetime(scores["date"].max()).date() if scores["date"].notna().any() else date.today()
    date_range = st.date_input("Date range", value=(min_date, max_date))

    files = sorted(scores["file_name"].dropna().unique().tolist())
    sel_files = st.multiselect("Files", options=files, default=files)

    # Tag universe
    all_tags = sorted({t for lst in scores["_tags_list"] for t in lst})
    sel_tags: List[str] = st.multiselect("Tags (AND filter)", options=all_tags)

    st.divider()
    st.write("**CSV path:**", f"`{CSV_PATH}`")
    st.write("**RAW_DIR:**", f"`{RAW_DIR}`")
    st.write("**PROC_DIR:**", f"`{PROC_DIR}`")

# Apply filters
mask = (
    (scores["date"].dt.date >= (date_range[0] if isinstance(date_range, tuple) else min_date)) &
    (scores["date"].dt.date <= (date_range[1] if isinstance(date_range, tuple) else max_date)) &
    (scores["file_name"].isin(sel_files))
)

if sel_tags:
    # AND logic across tags: keep rows that contain ALL selected tags
    mask &= scores["_tags_list"].apply(lambda lst: all(t in lst for t in sel_tags))

filt = scores[mask].copy()

# ------------------------------------
# KPI Row
# ------------------------------------
col1, col2, col3, col4, col5 = st.columns(5)
with col1:
    st.metric("Entries", len(filt))
with col2:
    st.metric("Avg E", round(filt["E"].mean(), 2) if len(filt) else 0)
with col3:
    st.metric("Avg C", round(filt["C"].mean(), 2) if len(filt) else 0)
with col4:
    st.metric("Avg R", round(filt["R"].mean(), 2) if len(filt) else 0)
with col5:
    st.metric("Avg P", round(filt["P"].mean(), 2) if len(filt) else 0)

# ------------------------------------
# Charts
# ------------------------------------
st.subheader("Timelines")
if len(filt):
    tl = filt.sort_values("date")
    fig_p = px.scatter(tl, x="date", y="P", color="file_name", title="Presence (P) over time",
                       labels={"P": "Presence (0–10)", "date": "Date", "file_name": "File"},
                       hover_data=["E","C","R","tags","notes"])
    fig_p.update_traces(mode="lines+markers")
    st.plotly_chart(fig_p, use_container_width=True)

    # Parallel coordinates for E/C/R/P
    fig_par = px.parallel_coordinates(
        tl[["E","C","R","P"]].dropna(),
        color=tl[["P"]].dropna().squeeze(),
        labels={"E":"E","C":"C","R":"R","P":"P"},
        title="Score profile — E/C/R/P",
        color_continuous_scale=px.colors.sequential.Viridis
    )
    st.plotly_chart(fig_par, use_container_width=True)

    # Tag frequency
    tags = (tl["_tags_list"].explode().dropna())
    if len(tags):
        tag_counts = tags.value_counts().reset_index()
        tag_counts.columns = ["tag","count"]
        fig_tags = px.bar(tag_counts, x="tag", y="count", title="Tag frequency")
        fig_tags.update_layout(xaxis_tickangle=-35)
        st.plotly_chart(fig_tags, use_container_width=True)
    else:
        st.info("No tags in the filtered set.")
else:
    st.warning("No rows match your filters.")

# ------------------------------------
# Table + Export
# ------------------------------------
st.subheader("Entries")
show_cols = ["date","file_name","E","C","R","P","tags","notes","id"]
st.dataframe(filt[show_cols].sort_values("date", ascending=False), use_container_width=True, height=420)

# CSV Export of filtered view
csv_export = filt[show_cols].sort_values("date", ascending=False).to_csv(index=False)
st.download_button("Download filtered CSV", data=csv_export, file_name="presence_scores_filtered.csv", mime="text/csv")

st.caption("Tip: Keep scoring in Jupyter, refresh here to see new entries.")
